<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>London Minecraft 3D – Simple</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #000;
      font-family: Arial, sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      font-size: 12px;
      z-index: 10;
      border-radius: 4px;
    }
  </style>
</head>
<body>
<div id="info">
  London Minecraft 3D (Prototype)<br/>
  Maus/Touch: drehen & zoomen · W/A/S/D: über die Straßen bewegen
</div>

<!-- Three.js + OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>
<script>
  let camera, scene, renderer, controls;
  let objects = [];
  let keys = { w: false, a: false, s: false, d: false };

  let prevTime = performance.now();

  init();
  animate();

  function init() {
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Szene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000010);
    scene.fog = new THREE.Fog(0x000010, 10, 150);

    // Kamera
    camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(35, 25, 35);

    // Orbit-Steuerung (Maus/Touch)
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 5, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = false; // Pan machen wir via WASD
    controls.maxPolarAngle = Math.PI / 2.05; // nicht unter Boden schauen

    // Licht
    const ambient = new THREE.AmbientLight(0x8888aa, 0.7);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(50, 100, -20);
    scene.add(dirLight);

    // Boden / Straßen im Minecraft-Style
    const groundSize = 40;
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);

    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x224422 });
    const streetMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
    const sidewalkMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });

    for (let x = -groundSize; x <= groundSize; x++) {
      for (let z = -groundSize; z <= groundSize; z++) {
        let mat = groundMaterial;

        // Hauptstraße in der Mitte (x ~ 0)
        if (Math.abs(x) < 3) mat = streetMaterial;
        // Gehwege daneben
        if ((Math.abs(x) === 3 || Math.abs(x) === 4) && Math.abs(z) < groundSize) {
          mat = sidewalkMaterial;
        }

        const cube = new THREE.Mesh(boxGeo, mat);
        cube.position.set(x, 0, z);
        cube.receiveShadow = true;
        scene.add(cube);
        objects.push(cube);
      }
    }

    // Gebäude-Cluster (London-Blocks)
    createBlockBuilding(-10, 1, -10, 6, 10, 6, 0x333366); // Hochhaus
    createBlockBuilding(10, 1, -5, 6, 8, 6, 0x553333);   // Backsteinhaus
    createBlockBuilding(-5, 1, 15, 4, 7, 4, 0x444444);   // kleiner Block
    createBigBenLike(0, 1, -25);                         // „Big Ben“-Turm light

    // Neon-Schilder für Night-Vibe
    createNeonSign(-10, 7, -8, 4, 2, 0x00aaff);
    createNeonSign(10, 6, -3, 3, 1.5, 0xff0077);

    // „Stadt-Lichtkegel“
    const spot = new THREE.SpotLight(0xffddaa, 0.4, 100, Math.PI / 6, 0.5, 1);
    spot.position.set(0, 20, 0);
    scene.add(spot);

    // Keyboard Events
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // Resize
    window.addEventListener('resize', onWindowResize);
  }

  function createBlockBuilding(cx, startY, cz, width, height, depth, color) {
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshLambertMaterial({ color: color });

    for (let y = startY; y < startY + height; y++) {
      for (let x = cx; x < cx + width; x++) {
        for (let z = cz; z < cz + depth; z++) {
          const cube = new THREE.Mesh(geo, mat);
          cube.position.set(x, y, z);
          cube.castShadow = true;
          cube.receiveShadow = true;
          scene.add(cube);
          objects.push(cube);
        }
      }
    }
  }

  function createBigBenLike(cx, startY, cz) {
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const towerMat = new THREE.MeshLambertMaterial({ color: 0x996633 });
    const clockMat = new THREE.MeshLambertMaterial({ color: 0xffffdd });

    // Turm
    for (let y = startY; y < startY + 16; y++) {
      for (let x = cx - 2; x <= cx + 2; x++) {
        for (let z = cz - 2; z <= cz + 2; z++) {
          const cube = new THREE.Mesh(geo, towerMat);
          cube.position.set(x, y, z);
          scene.add(cube);
          objects.push(cube);
        }
      }
    }

    // Uhr rundherum (helle Blöcke)
    const clockY = startY + 10;
    for (let x = cx - 1; x <= cx + 1; x++) {
      const cubeFront = new THREE.Mesh(geo, clockMat);
      cubeFront.position.set(x, clockY, cz - 3);
      scene.add(cubeFront);
      objects.push(cubeFront);

      const cubeBack = new THREE.Mesh(geo, clockMat);
      cubeBack.position.set(x, clockY, cz + 3);
      scene.add(cubeBack);
      objects.push(cubeBack);
    }
    for (let z = cz - 1; z <= cz + 1; z++) {
      const cubeLeft = new THREE.Mesh(geo, clockMat);
      cubeLeft.position.set(cx - 3, clockY, z);
      scene.add(cubeLeft);
      objects.push(cubeLeft);

      const cubeRight = new THREE.Mesh(geo, clockMat);
      cubeRight.position.set(cx + 3, clockY, z);
      scene.add(cubeRight);
      objects.push(cubeRight);
    }
  }

  function createNeonSign(x, y, z, w, h, color) {
    const geo = new THREE.BoxGeometry(w, h, 0.3);
    const mat = new THREE.MeshBasicMaterial({
      color: color
    });
    const sign = new THREE.Mesh(geo, mat);
    sign.position.set(x, y, z);
    scene.add(sign);
    objects.push(sign);
  }

  function onKeyDown(e) {
    switch (e.code) {
      case 'KeyW': keys.w = true; break;
      case 'KeyA': keys.a = true; break;
      case 'KeyS': keys.s = true; break;
      case 'KeyD': keys.d = true; break;
    }
  }

  function onKeyUp(e) {
    switch (e.code) {
      case 'KeyW': keys.w = false; break;
      case 'KeyA': keys.a = false; break;
      case 'KeyS': keys.s = false; break;
      case 'KeyD': keys.d = false; break;
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    // WASD bewegt Kamera & Target entlang der Straße
    const speed = 20;
    let moveX = 0;
    let moveZ = 0;

    if (keys.w) moveZ -= speed * delta;
    if (keys.s) moveZ += speed * delta;
    if (keys.a) moveX -= speed * delta;
    if (keys.d) moveX += speed * delta;

    if (moveX !== 0 || moveZ !== 0) {
      // Bewegung im Weltkoordinatensystem (Straßenrichtung: Z, Querstraße: X)
      camera.position.x += moveX * Math.cos(0) + moveZ * Math.sin(0);
      camera.position.z += moveZ * Math.cos(0) - moveX * Math.sin(0);

      controls.target.x += moveX * Math.cos(0) + moveZ * Math.sin(0);
      controls.target.z += moveZ * Math.cos(0) - moveX * Math.sin(0);
    }

    controls.update();
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
